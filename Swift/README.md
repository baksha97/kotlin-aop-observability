Below is a **draft** `README.md` for my **Capture** library. It follows a style similar to SwiftLog’s documentation and explains the core concepts, usage, and extensibility options. This library doesn't exist yet. It's a work in progress. 

---

# Capture

**Capture** is a lightweight, macro-based instrumentation library for Swift, inspired by [SwiftLog](https://github.com/apple/swift-log). It provides a simple API for capturing execution data—like duration, errors, and calling context—around your functions. Capture’s instrumentation can be added automatically via Swift macros (`@Capture`), making it easy to observe and measure function performance without manually wrapping code with timers and error handling.

## Table of Contents

1. [Introduction](#introduction)  
2. [Features](#features)  
3. [Getting Started](#getting-started)  
4. [Basic Usage](#basic-usage)  
   - [Using `@Capture` Macro](#using-capture-macro)  
   - [Overriding the Capture Key](#overriding-the-capture-key)  
5. [Data Collection](#data-collection)  
6. [Extensibility](#extensibility)  
   - [Custom Collectors](#custom-collectors)  
   - [Bootstrapping Collectors](#bootstrapping-collectors)  
7. [Examples](#examples)  
8. [Implementation Details](#implementation-details)  
9. [License](#license)

---

## Introduction

The goal of **Capture** is to provide a dead-simple way to instrument your Swift code with minimal boilerplate. If you’ve ever added timing code and logging statements inside your functions (only to remove them later), Capture is for you:

1. Mark a function with `@Capture`.
2. The macro automatically times the function execution.
3. It also captures thrown errors and key contextual info: file name, line number, function name.
4. This data is then reported to a **Collector**, which you can replace or customize for different use cases (e.g., metrics, logging, profiling).

**At a high level**, Capture works similarly to how [swift-log](https://github.com/apple/swift-log) allows you to swap log handlers. Instead, Capture allows you to swap data collectors.

---

## Features

- **Automatic Instrumentation:** Add `@Capture` to any function, and the library wraps your function body with timing and error handling code.
- **Override Capture Key:** Use the `@CaptureKey("custom.key")` macro to override the default function name as the “capture key.”
- **Works with Sync & Async:** The instrumentation is designed to handle both synchronous and asynchronous functions.
- **Minimal Overhead:** The macro does all the boilerplate for you, so you avoid manual setup code.
- **Customizable Collection Pipeline:** Plug in your own collector conforming to the `Collector` protocol. You have complete freedom to store or process function data in whichever way you want—e.g., send metrics to your favorite monitoring service.

---

## Getting Started

### Swift Package Manager

To integrate **Capture** into your project using the [Swift Package Manager (SPM)](https://www.swift.org/package-manager/), add the following line to the dependencies array in your **Package.swift**:

```swift
dependencies: [
    .package(url: "https://github.com/baksha97/capture.git", from: "1.0.0")
]
```

And add `"Capture"` as a dependency for your target:

```swift
.target(
    name: "YourTarget",
    dependencies: [
        .product(name: "Capture", package: "capture"),
    ]
)
```

---

## Basic Usage

### Using `@Capture` Macro

Simply annotate your function with `@Capture`:

```swift
import Capture

@Capture
func nonThrowingSync() {
    // The macro will automatically track the start time
    // and end time of this function's execution.
    print("nonThrowingSync is running...")
    // The timing and other capture info are collected and passed
    // to the active Collector at function exit.
}
```

That’s it! When `nonThrowingSync` runs, Capture will automatically measure:

- **Execution time**  
- **File name / line number** where the function is declared  
- **Function name** (by default, used as the “capture key”)  
- **Any thrown error** (for throwing functions)  

### Overriding the Capture Key

By default, the function’s name acts as the capture key. However, if you want to override it:

```swift
@CaptureKey("custom.key.name")
@Capture
func someFunction() {
    // ...
}
```

The `@CaptureKey` macro must precede the `@Capture` macro. Now the collector sees `"custom.key.name"` as the function’s key, instead of `"someFunction"`.

---

## Data Collection

At function exit, Capture creates a `CaptureInfo` struct:

```swift
public struct CaptureInfo {
    public let key: String
    public let functionName: String
    public let fileName: String
    public let lineNumber: Int
    public let duration: TimeInterval
    public let error: Error?
}
```

All `CaptureInfo` objects generated by your annotated functions are automatically delivered to the global or local collector(s) you bootstrap. The default collector might simply print the data to stdout. You can configure a custom collector to push these metrics to a logging or monitoring service.

---

## Extensibility

### Custom Collectors

To customize how instrumentation data is stored or reported, implement the `Collector` protocol:

```swift
public protocol Collector {
    func capture(_ info: CaptureInfo)
}
```

For example, you could write a collector that logs data to the console:

```swift
struct ConsoleCollector: Collector {
    func capture(_ info: CaptureInfo) {
        print("[CAPTURE] \(info.key) took \(info.duration) seconds.")
        if let err = info.error {
            print("[CAPTURE] Error: \(err)")
        }
    }
}
```

### Bootstrapping Collectors

Similar to how `LoggingSystem.bootstrap` works in SwiftLog, Capture will offer an API to set your own default collector. For instance:

```swift
CaptureSystem.bootstrap(ConsoleCollector())

@Capture
func sayHello() {
    print("Hello from captured function!")
}
```

When `sayHello()` executes, the instrumentation will automatically call `ConsoleCollector.capture(_:)`.

**Note:** The exact `bootstrap` API design may vary, but the concept is the same as in `swift-log`: you have a global registry that you can replace with a different collector or a multiplex of collectors.

---

## Examples

### Synchronous Function That Throws

```swift
@Capture
func mightThrow(_ value: Int) throws -> String {
    if value < 0 {
        throw NSError(domain: "InvalidNegativeValue", code: 1001, userInfo: nil)
    }
    return "\(value) was valid!"
}
```

Upon calling `mightThrow(-1)`, Capture will capture the thrown error and record the total execution time.

### Asynchronous Function

```swift
@Capture
func fetchData() async throws -> Data {
    // This is an async function
    // The `@Capture` macro wraps it with async instrumentation
    return try await networkClient.requestData()
}
```

When `fetchData()` completes (or if it throws), Capture records the data.

---

## Implementation Details

- The `@Capture` macro expands to wrap the function body in a `withCapture` call.  
- `withCapture` starts a timer before executing the function body, then measures the elapsed time and potential error afterwards.  
- For throwing functions, Capture uses a `rethrows`-compatible wrapper to preserve the original error context.  
- By default, each function’s capture key is its name, but that can be overridden via `@CaptureKey("...")`.  

Inspired by [swift-log](https://github.com/apple/swift-log), we provide a simple global approach to collector injection with minimal overhead.

---

## License

Capture is released under the Apache License 2.0. See [LICENSE](LICENSE) for details.
